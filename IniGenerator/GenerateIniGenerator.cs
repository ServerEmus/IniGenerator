using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace IniGenerator;

[Generator]
public class GenerateIniGenerator : IIncrementalGenerator
{

    public static string GetNamespaceFrom(SyntaxNode s) => s.Parent switch
    {
        BaseNamespaceDeclarationSyntax namespaceDeclarationSyntax => namespaceDeclarationSyntax.Name.ToString(),
        null => string.Empty,
        _ => GetNamespaceFrom(s.Parent)
    };

    public static bool AttributeNameHas(AttributeSyntax attribute)
    {
        return attribute.Name.ToFullString().Contains(Consts.GenerateIniAttributeName);
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var res = context.SyntaxProvider.ForAttributeWithMetadataName(
            $"{Consts.Namespace}.{Consts.GenerateIniAttributeName}Attribute",
            static (node, _) => node is ClassDeclarationSyntax classDeclaration && classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)),
            static (ctx, _) =>
            {
                var classDec = (ClassDeclarationSyntax)ctx.TargetNode;
                GenerateIniData data = new()
                {
                    Namespace = GetNamespaceFrom(classDec),
                    ClassName = classDec.Identifier.Text,
                    TypeSymbols = []
                };

                var attribute = classDec.AttributeLists.Where(static x => x.Attributes.Any(
                    static x => AttributeNameHas(x)
                    ));

                foreach (var attrList in attribute)
                {
                    var attributeSyntaxes = attrList.Attributes.Where(static x => AttributeNameHas(x));

                    foreach (var attributeSyntax in attributeSyntaxes)
                    {
                        var item = attributeSyntax.ArgumentList!.Arguments[0];
                        var typeSymbol = (item.Expression is TypeOfExpressionSyntax typeOfSyntax)
                        ? ctx.SemanticModel.GetTypeInfo(typeOfSyntax.Type).Type
                        : null;
                        if (typeSymbol is not null)
                        {
                            data.TypeSymbols.Add(typeSymbol);
                        }
                    }
                }
                
                return data;
            });

        context.RegisterSourceOutput(context.CompilationProvider.Combine(res.Collect()), (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    private void GenerateCode(SourceProductionContext ctx, Compilation compilation, ImmutableArray<GenerateIniData> datas)
    {
        StringBuilder stringBuilder = new();
        foreach (GenerateIniData data in datas)
        {
            foreach (var typeSymbol in data.TypeSymbols)
            {
                stringBuilder.Clear();
                stringBuilder.AppendLine("// <auto-generated />");
                stringBuilder.AppendLine("using IniParser;");
                stringBuilder.AppendLine("using IniParser.Model;");

                stringBuilder.AppendLine();

                if (!string.IsNullOrEmpty(data.Namespace))
                    stringBuilder.AppendLine($"namespace {data.Namespace};");

                stringBuilder.AppendLine();

                stringBuilder.AppendLine($"partial class {data.ClassName}");
                stringBuilder.AppendLine("{");

                IniCodeGen.MainIniCodeGenWork(stringBuilder, compilation, typeSymbol);

                stringBuilder.AppendLine("}");

                ctx.AddSource($"{data.ClassName}_{typeSymbol.Name}.g.cs", stringBuilder.ToString());
            }
        }
    }
}